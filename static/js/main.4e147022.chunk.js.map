{"version":3,"sources":["FlexModelUtils.ts","hooks/useMediaQuery.ts","App.tsx","index.tsx"],"names":["analyseRow","row","updateIfNeeded","widthNeeded","heightNeeded","getChildren","forEach","node","getType","TabSetNode","TYPE","ts","tabset","TabNode","Error","t","Math","max","getConfig","minHeight","minWidth","setSize","Actions","updateNodeAttributes","getId","getModel","doAction","getTabSetMinSize","getOrientation","Orientation","HORZ","RowNode","size","analyseModel","modelToAnalyse","prioTabset","undefined","activeTabset","rootRow","getRoot","console","log","visitNodes","toLowerCase","isActive","result","model","toJson","createUseMedia","effect","query","defaultState","useState","state","setState","mounted","mediaQueryList","window","matchMedia","onChange","Boolean","matches","addListener","removeListener","useMedia","useEffect","useLayoutEffect","templateModel","Model","fromJson","global","layout","App","currentModel","setCurrentModel","stachedModel","setStachedModel","canvasToggleAbs","setCanvasToggleAbs","stackStrategy","setStackStrategy","layoutRef","useRef","isTooNarrow","newModel","saveCurrentJson","copyOfCurrent","analyzedModel","targetTabset","tabsToMove","getParent","push","mv","moveNode","DockLocation","CENTER","stackZAxis","targetRow","tabSetsToMove","BOTTOM","stackYAxis","isTooShortForCurrentModel","className","style","height","value","event","target","onClick","current","addTabWithDragAndDropIndirect","component","name","config","text","ref","onAction","action","setTimeout","onModelChange","factory","getComponent","dangerouslySetInnerHTML","__html","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4e147022.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, IJsonModel, Action, Orientation, Actions, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\n\r\n\r\n\r\nexport interface IAnalyzedModel {\r\n    model: Model,\r\n    activeTabset: FLNode | undefined,\r\n    prioTabset: FLNode | undefined,\r\n    widthNeeded?: number,\r\n    heightNeeded?: number,\r\n    rootRow?: FLNode | undefined\r\n}\r\n\r\ninterface IDimensions {\r\n    widthNeeded: number,\r\n    heightNeeded: number,\r\n}\r\n\r\n\r\nconst getTabSetMinSize = (tabset: TabSetNode, updateIfNeeded: boolean): IDimensions => {\r\n    let heightNeeded = 0;\r\n    let widthNeeded = 0;\r\n\r\n    // iterate through the tabs to get min sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() != TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const t = node as TabNode;\r\n        heightNeeded = Math.max(heightNeeded, t.getConfig().minHeight);\r\n        widthNeeded = Math.max(widthNeeded, t.getConfig().minWidth);\r\n\r\n    })\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if (updateIfNeeded && (heightNeeded > 0 || widthNeeded > 0)) {\r\n        const setSize = Actions.updateNodeAttributes(tabset.getId(), { minWidth: widthNeeded, minHeight: heightNeeded });\r\n        tabset.getModel().doAction(setSize);\r\n    }\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded\r\n    }\r\n\r\n}\r\n\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean): IDimensions => {\r\n    let widthNeeded = 0;\r\n    let heightNeeded = 0;\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = getTabSetMinSize(node as TabSetNode, updateIfNeeded);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                widthNeeded += ts.widthNeeded;\r\n                heightNeeded = Math.max(heightNeeded, ts.heightNeeded);\r\n            } else {\r\n                widthNeeded = Math.max(widthNeeded, ts.widthNeeded);\r\n                heightNeeded += ts.heightNeeded;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const size = analyseRow(node as RowNode, updateIfNeeded);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                if (size.widthNeeded) widthNeeded += size.widthNeeded;\r\n                if (size.heightNeeded) heightNeeded = Math.max(heightNeeded, size.heightNeeded);\r\n            } else {\r\n                if (size.widthNeeded) widthNeeded = Math.max(widthNeeded, size.widthNeeded);\r\n                if (size.heightNeeded) heightNeeded += size.heightNeeded;\r\n            }\r\n        }\r\n    })\r\n\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded\r\n    }\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = false): IAnalyzedModel => {\r\n\r\n    let prioTabset: TabSetNode | undefined = undefined;\r\n    let activeTabset: TabSetNode | undefined = undefined;\r\n    let rootRow = modelToAnalyse.getRoot();\r\n\r\n\r\n    console.log(\"doign analysis\");\r\n    // find the tabset that is currently active, and also the first tabset (as fallback)\r\n    modelToAnalyse.visitNodes(node => {\r\n\r\n        if (!prioTabset && node.getType().toLowerCase() === 'tabset') prioTabset = node as TabSetNode;\r\n\r\n        if (!activeTabset && node.getType().toLowerCase() === 'tabset' && (node as TabSetNode).isActive()) {\r\n            activeTabset = node as TabSetNode;\r\n        }\r\n\r\n    });\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(rootRow, updateIfNeeded);\r\n\r\n    console.log(\"done\");\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        activeTabset: activeTabset,\r\n        prioTabset: prioTabset,\r\n        rootRow,\r\n        widthNeeded: size.widthNeeded,\r\n        heightNeeded: size.heightNeeded\r\n    }\r\n\r\n    console.log(modelToAnalyse.toJson());\r\n\r\n    console.log(`SIZE : ${size.heightNeeded} x ${size.widthNeeded}`)\r\n    return result;\r\n}\r\n\r\n\r\n\r\nexport const stackZAxis = (analyzedModel: IAnalyzedModel): IAnalyzedModel => {\r\n\r\n    let targetTabset: FLNode = analyzedModel.activeTabset ? analyzedModel.activeTabset : analyzedModel.prioTabset!;\r\n    let tabsToMove: FLNode[] = [];\r\n\r\n    analyzedModel.model.visitNodes((node) => {\r\n        console.log(node.getType() + \" is \" + node.getId());\r\n        if (node.getParent()) {\r\n            console.log(\" and parent is: \" + node!.getParent()!.getId());\r\n\r\n        } else {\r\n            console.log(\"none\")\r\n        }\r\n        if (node.getType().toLowerCase() === 'tab' && node.getParent()?.getId() != targetTabset!.getId()) {\r\n            tabsToMove.push(node);\r\n        }\r\n    });\r\n\r\n    tabsToMove.forEach(node => {\r\n        let mv = Actions.moveNode(node.getId(), targetTabset?.getId(), DockLocation.CENTER, -1, false);\r\n        analyzedModel.model.doAction(mv);\r\n    })\r\n\r\n\r\n    return analyseModel(analyzedModel.model);\r\n}\r\n\r\nexport const stackYAxis = (analyzedModel: IAnalyzedModel): IAnalyzedModel => {\r\n    let activeTabset: FLNode = analyzedModel.activeTabset ? analyzedModel.activeTabset : analyzedModel.prioTabset!;\r\n    let targetRow = analyzedModel.rootRow;\r\n    let tabSetsToMove: FLNode[] = [];\r\n\r\n    if (targetRow) {\r\n\r\n        analyzedModel.model.visitNodes((node) => {\r\n            console.log(node.getType() + \" is \" + node.getId());\r\n            if (node.getType().toLowerCase() === 'tabset' && node.getId() != activeTabset.getId()) {\r\n                tabSetsToMove.push(node);\r\n            }\r\n        });\r\n\r\n\r\n        tabSetsToMove.forEach(node => {\r\n            let mv = Actions.moveNode(node.getId(), targetRow!.getId(), DockLocation.BOTTOM, -1);\r\n            console.log(mv);\r\n\r\n            console.log(\"before parent IS \" + node.getParent()!.getId())\r\n            console.log(\"node is \"); console.log(node.toJson());\r\n            analyzedModel.model.doAction(mv);\r\n\r\n            // targetRow = node.getParent();\r\n            console.log(\"after parent IS \" + node.getParent()!.getId())\r\n\r\n\r\n\r\n        })\r\n\r\n    }\r\n\r\n    return analyseModel(analyzedModel.model);\r\n}\r\n\r\n","// Based on https://github.com/streamich/use-media\r\n// simplified for initial implementation\r\n// more research needed to identify best library for media queries, and to expand to be a global App feature in context\r\n// Streamich has some good features, but maybe there is something better\r\nimport React, { DependencyList, EffectCallback } from 'react';\r\n\r\nimport { useState, useEffect, useLayoutEffect } from 'react';\r\n\r\nexport type Effect = (effect: EffectCallback, deps?: DependencyList) => void;\r\n\r\nconst createUseMedia = (effect: Effect) => (\r\n    query: string,\r\n    defaultState = false,\r\n) => {\r\n    const [state, setState] = useState(defaultState);\r\n\r\n    effect(() => {\r\n        let mounted = true;\r\n        const mediaQueryList: MediaQueryList = window.matchMedia(query);\r\n\r\n        const onChange = () => {\r\n            if (!mounted) {\r\n                return;\r\n            }\r\n            setState(Boolean(mediaQueryList.matches));\r\n        };\r\n\r\n        mediaQueryList.addListener(onChange);\r\n        setState(mediaQueryList.matches);\r\n\r\n        return () => {\r\n            mounted = false;\r\n            mediaQueryList.removeListener(onChange);\r\n        };\r\n    }, [query]);\r\n\r\n    return state;\r\n};\r\n\r\nexport const useMedia = createUseMedia(useEffect);\r\nexport const useMediaLayout = createUseMedia(useLayoutEffect);\r\n\r\nexport default useMedia;","import React, { useEffect, useRef, useState } from 'react';\nimport './App.css';\nimport 'flexlayout-react/style/light.css'\n\nimport { Layout, Model, TabNode, TabSetNode, IJsonModel, Action, Actions, Node as FLNode } from 'flexlayout-react';\n\nimport { analyseModel, stackZAxis, IAnalyzedModel, stackYAxis } from './FlexModelUtils';\n\nimport useMedia from './hooks/useMediaQuery';\n\nvar json: IJsonModel = {\n  global: {\n    \"rootOrientationVertical\": false\n  }, // {tabSetEnableTabStrip:false}, // to have just splitters\n  layout: {\n    \"type\": \"row\",\n    \"weight\": 100,\n    \"children\": [\n      {\n        \"type\": \"tabset\",\n        \"weight\": 50,\n        \"selected\": 0,\n        \"children\": [\n          {\n            \"type\": \"tab\",\n            \"name\": \"Things to try\",\n            \"component\": \"text\",\n            \"config\": {\n              \"text\": \"<ul><li>drag tabs</li><li>drag splitters</li><li>double click on tab to rename</li><li>double click on tabstrip to maximize</li><li>use the Add button to add another tab</li></ul>\",\n              \"minWidth\": 510,\n              \"minHeight\": 350,\n            }\n          }\n        ]\n      },\n\n      {\n        \"type\": \"tabset\",\n        \"weight\": 50,\n        \"selected\": 0,\n        \"children\": [\n          {\n            \"type\": \"tab\",\n            \"name\": \"two\",\n            \"component\": \"text\",\n            \"config\": {\n              \"text\": \"\",\n              \"minWidth\": 510,\n              \"minHeight\": 350,\n            }\n          }\n        ]\n      },\n      {\n        \"type\": \"tabset\",\n        \"weight\": 50,\n        \"selected\": 0,\n        \"children\": [\n          {\n            \"type\": \"tab\",\n            \"name\": \"three\",\n            \"component\": \"text\",\n            \"config\": {\n              \"text\": \"\",\n              \"minWidth\": 510,\n              \"minHeight\": 350\n            }\n          }\n        ]\n      }\n\n\n    ]\n  }\n};\n\nconst templateModel = analyseModel(Model.fromJson(json), true);\n\n\nfunction App() {\n  // currentMOdel is what we're currently rendering.\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stachedModel\" so that it can be restored later\n  const [currentModel, setCurrentModel] = useState(() => { return templateModel });\n  const [stachedModel, setStachedModel] = useState<IAnalyzedModel>();\n\n  const [canvasToggleAbs, setCanvasToggleAbs] = useState(false);\n  const [stackStrategy, setStackStrategy] = useState('Z');\n\n  const containerRef = useRef(null);\n  const layoutRef = useRef(null);\n\n\n\n  // If there is a stashed model, I want to switch back to it as soon as possible\n  // If there is no stashed model (yet) then trigger when the current model becomes too big for viewport\n  const isTooNarrow = useMedia(`(max-width: ${stachedModel ? (stachedModel as IAnalyzedModel).widthNeeded : currentModel.widthNeeded}px)`);\n  useEffect(() => {\n    if (currentModel) {\n      if (!isTooNarrow) {\n        if (stachedModel) {\n          setCurrentModel(stachedModel);\n          setStachedModel(undefined);\n        }\n      } else {\n        // stash the current model\n        let saveCurrentJson = currentModel.model.toJson();\n        let copyOfCurrent = { ...currentModel };\n        copyOfCurrent.model = Model.fromJson(saveCurrentJson);\n        setStachedModel(copyOfCurrent);\n\n        // alter current model\n        let newModel: IAnalyzedModel;\n\n        if (isTooNarrow) {\n          if (stackStrategy === 'Z') {\n            newModel = stackZAxis(currentModel);\n            setCanvasToggleAbs(false);\n          } else {\n            newModel = stackYAxis(currentModel);\n          }\n          setCurrentModel(newModel);\n        }\n      }\n    }\n  }, [isTooNarrow]);\n\n\n  // If too short for current model switch to absolute, \n  const isTooShortForCurrentModel = useMedia(`(max-height: ${currentModel.heightNeeded}px)`);\n  useEffect(() => {\n    if (currentModel) {\n      if (!isTooShortForCurrentModel) {\n        setCanvasToggleAbs(false); console.log(\"REL CANVAS :\" + currentModel.heightNeeded);\n      } else {\n        setCanvasToggleAbs(true); console.log(\"ABS CANVAS :\" + currentModel.heightNeeded);\n      }\n    }\n  }, [isTooShortForCurrentModel]);\n\n\n  const factory = (node: TabNode) => {\n    var component = node.getComponent();\n    if (component === \"text\") {\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().text }} />;\n    }\n  }\n\n  const onAdd = (event: any) => {\n    (layoutRef.current! as Layout).addTabWithDragAndDropIndirect(\"Add panel<br>(Drag to location)\", {\n      component: \"text\",\n      name: \"added\",\n      config: { text: \"i was added\", minHeight: 300, minWidth: 400 }\n    }, undefined);\n  }\n\n  const interceptAction = (action: Action) => {\n    console.log(action);\n\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\n    // this new tabset will not have a minimum size and so this needs to be set\n    // also for deletion of tabs or addition of nodes, the size may be impacted\n    setTimeout(() => { setCurrentModel(analyseModel(currentModel.model, true /* update min sizes if needed*/)); }, 100);\n\n    return action;\n  }\n\n  const changeStrategy = (event: any) => {\n    setStackStrategy(event.target.value);\n  }\n\n  const modelChanged = (model: Model) => {\n    console.log(\"model changed\");\n    console.log(model);\n\n    setCurrentModel(analyseModel(model, false /* avoid infinite loop*/));\n  }\n\n\n  return (\n\n    <div className=\"outer\" style={canvasToggleAbs ? { height: currentModel.heightNeeded + 'px' } : { height: '100%' }}>\n      <span> Stacking strategy:</span>\n      <select value={stackStrategy} onChange={changeStrategy}>\n        <option value=\"Z\">Z axis</option>\n        <option value=\"Y\">Y axis</option>\n      </select>\n      <button onClick={onAdd}>Add</button>\n      <div className=\"inner\" >\n        {currentModel && (\n          <Layout ref={layoutRef}\n            onAction={interceptAction}\n            onModelChange={modelChanged}\n            model={currentModel.model}\n            factory={factory} />)}\n      </div>\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}