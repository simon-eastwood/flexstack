{"version":3,"sources":["FlexModelUtils.ts","hooks/useMediaQuery.ts","LoadTemplate.ts","App.tsx","index.tsx"],"names":["analyseRow","row","updateIfNeeded","widthNeeded","heightNeeded","getChildren","forEach","node","getType","TabSetNode","TYPE","ts","tabset","TabNode","Error","t","Math","max","getConfig","minHeight","minWidth","getMinWidth","getMinHeight","setSize","Actions","updateNodeAttributes","getId","getModel","doAction","getTabSetMinSize","getOrientation","Orientation","HORZ","RowNode","size","analyseModel","modelToAnalyse","lowestPrioTabset","undefined","activeTabset","rootRow","getRoot","console","log","visitNodes","toLowerCase","isActive","result","model","toJson","cloneModel","modelToClone","saveCurrentJson","clone","Model","fromJson","moveTabset","maxPanel","panels","Map","totalNrOfTabSets","panel","panelNr","set","mv","moveNode","get","DockLocation","BOTTOM","removeTabset","maxPanelNr","childrenToMove","child","destinationId","panelPreferences","Array","from","keys","dest","CENTER","del","deleteTabset","done","createUseMedia","effect","query","defaultState","useState","state","setState","mounted","mediaQueryList","window","matchMedia","onChange","Boolean","matches","addListener","removeListener","useMedia","useEffect","useLayoutEffect","taskTemplateLayout","global","layout","loadTemplateModel","howToStack","App","stashedModels","_setStashedModels","maxPanels","setMaxPanels","height","width","canvasToggleAbs","setCanvasToggleAbs","stackStrategy","setStackStrategy","layoutRef","useRef","currentModel","length","stashSet","downsizeModel","stackDirection","alteredModel","previousModelWidth","newStash","m","push","innerWidth","isTooNarrow","tooWide","isTooWide","sourceModel","targetModel","lastTabSet","actions","getNodeById","deleteTab","parent","getParent","addNode","RIGHT","action","migrateModel","slice","stashPop","isTooShort","absStyle","className","style","onClick","event","current","addTabWithDragAndDropIndirect","component","name","config","text","value","target","parseInt","ref","onAction","setTimeout","onModelChange","factory","getComponent","dangerouslySetInnerHTML","__html","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d6c63dec.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\n\r\n\r\n\r\nexport interface IAnalyzedModel {\r\n    model: Model,\r\n    activeTabset: FLNode | undefined,\r\n    lowestPrioTabset: FLNode | undefined,\r\n\r\n    widthNeeded?: number,\r\n    heightNeeded?: number,\r\n    rootRow?: FLNode | undefined\r\n}\r\n\r\ninterface IDimensions {\r\n    widthNeeded: number,\r\n    heightNeeded: number,\r\n}\r\n\r\n\r\nconst getTabSetMinSize = (tabset: TabSetNode, updateIfNeeded: boolean): IDimensions => {\r\n    let heightNeeded = 0;\r\n    let widthNeeded = 0;\r\n\r\n    // iterate through the tabs to get min sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const t = node as TabNode;\r\n        heightNeeded = Math.max(heightNeeded, t.getConfig().minHeight);\r\n        widthNeeded = Math.max(widthNeeded, t.getConfig().minWidth);\r\n\r\n    })\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if ((updateIfNeeded && (heightNeeded > 0 || widthNeeded > 0)) &&\r\n        (tabset.getMinWidth() != widthNeeded || tabset.getMinHeight() != heightNeeded)) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n        const setSize = Actions.updateNodeAttributes(tabset.getId(), { minWidth: widthNeeded, minHeight: heightNeeded });\r\n        tabset.getModel().doAction(setSize);\r\n    }\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded\r\n    }\r\n\r\n}\r\n\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean): IDimensions => {\r\n    let widthNeeded = 0;\r\n    let heightNeeded = 0;\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = getTabSetMinSize(node as TabSetNode, updateIfNeeded);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                widthNeeded += ts.widthNeeded;\r\n                heightNeeded = Math.max(heightNeeded, ts.heightNeeded);\r\n            } else {\r\n                widthNeeded = Math.max(widthNeeded, ts.widthNeeded);\r\n                heightNeeded += ts.heightNeeded;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const size = analyseRow(node as RowNode, updateIfNeeded);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                if (size.widthNeeded) widthNeeded += size.widthNeeded;\r\n                if (size.heightNeeded) heightNeeded = Math.max(heightNeeded, size.heightNeeded);\r\n            } else {\r\n                if (size.widthNeeded) widthNeeded = Math.max(widthNeeded, size.widthNeeded);\r\n                if (size.heightNeeded) heightNeeded += size.heightNeeded;\r\n            }\r\n        }\r\n    })\r\n\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded\r\n    }\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = false): IAnalyzedModel => {\r\n\r\n    let lowestPrioTabset: TabSetNode | undefined = undefined;\r\n    let activeTabset: TabSetNode | undefined = undefined;\r\n    let rootRow = modelToAnalyse.getRoot();\r\n\r\n\r\n    console.log(\"Too doing analysis (\" + updateIfNeeded);\r\n    // find the tabset that is currently active, and also the first tabset (as fallback)\r\n    modelToAnalyse.visitNodes(node => {\r\n\r\n        if (!lowestPrioTabset && node.getType().toLowerCase() === 'tabset') lowestPrioTabset = node as TabSetNode;\r\n\r\n        if (!activeTabset && node.getType().toLowerCase() === 'tabset' && (node as TabSetNode).isActive()) {\r\n            activeTabset = node as TabSetNode;\r\n        }\r\n\r\n    });\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(rootRow, updateIfNeeded);\r\n\r\n    console.log(\"done\");\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        activeTabset: activeTabset,\r\n        lowestPrioTabset: lowestPrioTabset,\r\n        rootRow,\r\n        widthNeeded: size.widthNeeded,\r\n        heightNeeded: size.heightNeeded\r\n    }\r\n\r\n    console.log(modelToAnalyse.toJson());\r\n\r\n    console.log(`SIZE : ${size.heightNeeded} x ${size.widthNeeded}`)\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\n\r\n\r\nexport const migrateModel = (sourceModel: IAnalyzedModel, targetModel: IAnalyzedModel) => {\r\n    let actions: Action[] = [];\r\n    let lastTabSet: TabSetNode;\r\n    console.log(\"migrating model\"); console.log(sourceModel); console.log(targetModel);\r\n\r\n    // Which nodes need to be deleted from target?\r\n    targetModel.model.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            if (!sourceModel.model.getNodeById(node.getId())) {\r\n                actions.push(Actions.deleteTab(node.getId()));\r\n            }\r\n        } else if (node.getType() === TabSetNode.TYPE) {\r\n            lastTabSet = node as TabSetNode;\r\n        }\r\n    })\r\n\r\n    // which nodes need to added to the target?\r\n    sourceModel.model.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            if (!targetModel.model.getNodeById(node.getId())) {\r\n                // add to the same parent if possible\r\n                const parent = node.getParent();\r\n                if (parent!.getType() === TabSetNode.TYPE && targetModel.model.getNodeById(parent!.getId())) {\r\n                    actions.push(Actions.addNode(node.toJson(), parent!.getId(), DockLocation.CENTER, -1, false));\r\n                } else {\r\n                    // Otherwise add to the last tabset in the model\r\n                    if (lastTabSet) {\r\n                        actions.push(Actions.addNode(node.toJson(), lastTabSet.getId(), DockLocation.CENTER, -1, false));\r\n                    } else {\r\n                        actions.push(Actions.addNode(node.toJson(), targetModel.model.getRoot().getId(), DockLocation.RIGHT, -1, false));\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    });\r\n\r\n    actions.forEach(action => {\r\n        targetModel.model.doAction(action);\r\n    });\r\n}\r\n\r\nexport const moveTabset = (model: Model): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n    let totalNrOfTabSets = 0;\r\n\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            totalNrOfTabSets++;\r\n            if ((node as TabSetNode).getConfig()?.panel) {\r\n                const ts = node as TabSetNode;\r\n                const panelNr = ts.getConfig().panel;\r\n                panels.set(panelNr, ts);\r\n                maxPanel = (panelNr > maxPanel) ? panelNr : maxPanel;\r\n            }\r\n        }\r\n    });\r\n\r\n    if (totalNrOfTabSets < 2) {\r\n        // can't move the  last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    if (panels.size > 0) {\r\n        let mv = Actions.moveNode(panels.get(maxPanel)!.getId(), model.getRoot().getId() ,DockLocation.BOTTOM, -1, false);\r\n        model.doAction(mv);   \r\n    }\r\n\r\n    return model;\r\n}\r\n\r\n\r\n// 1. find the tabsets within the model and put them into a map based on their panel number\r\n// 2. for each panel, if its panel id is larger than max panel then it needs to be deleted but not before...\r\n// 3. ...moving its children to their preferred destination specified in panelPreferences.\r\n// The ids in this list are checked one-by-one until one is found that is \"small enough\" that that panel stills exists.\r\n// The child nodes are then moved to their new preferred / available panel\r\nexport const removeTabset = (model: Model, maxPanelNr?: number): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n    let totalNrOfTabSets = 0;\r\n\r\n  \r\n    // first find out how many tabsets there are in the model and collect the ones with a \"panel\" number. Record max panel nr found\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            totalNrOfTabSets++;\r\n            if ((node as TabSetNode).getConfig()?.panel) {\r\n                const ts = node as TabSetNode;\r\n                const panelNr = ts.getConfig().panel;\r\n                panels.set(panelNr, ts);\r\n                maxPanel = (panelNr > maxPanel) ? panelNr : maxPanel;\r\n            }\r\n        }\r\n    });\r\n    maxPanel = (maxPanelNr) ? maxPanelNr : maxPanel;\r\n\r\n    if (totalNrOfTabSets < 2) {\r\n        // don't want to delete the last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    if (panels.size > 0) {\r\n        // if there are tabsets in the model marked with a panel id then use this to decide which one to delete\r\n        panels.forEach((ts, panelNr) => {\r\n            if (panelNr >= maxPanel) {\r\n                // move the children\r\n                const childrenToMove = new Map<TabNode, TabSetNode>();\r\n                ts.getChildren().forEach((child) => {\r\n                    let destinationId = -1; \r\n                    if (child.getType() === 'tab' && (child as TabNode).getConfig().panelPreferences) {\r\n                        // get the preferred panel for layouts with MAXPANEL panels\r\n                        destinationId = (child as TabNode).getConfig().panelPreferences[maxPanel - 2];\r\n                        \r\n                    }\r\n                    // if cant find preferred desination, just take first one\r\n                    if (destinationId === -1) {\r\n                        const ps = Array.from(panels.keys());\r\n                        destinationId = ps[0];\r\n                    }\r\n                    childrenToMove.set(child as TabNode, panels.get(destinationId)!);\r\n                })\r\n\r\n                childrenToMove.forEach((dest, child) => {\r\n                        let mv = Actions.moveNode(child.getId(), dest.getId(),  DockLocation.CENTER, -1, false);\r\n                        model.doAction(mv);       \r\n                })\r\n\r\n\r\n                // delete the tabset. Actually an empty tabset will not be rendered\r\n                // but this will confuse the task of finding next tab to remove\r\n                // so better to clean up\r\n                let del = Actions.deleteTabset(ts.getId());\r\n                model.doAction(del);\r\n            }\r\n        })\r\n    } else {\r\n        let done = false;\r\n        // no tabsets in the model have config.panel set so just delete the first one that isnt active\r\n        model.visitNodes((node) => {\r\n            if (!done && node.getType() === 'tabset' && !(node as TabSetNode).isActive()) {\r\n                let del = Actions.deleteTabset(node.getId());\r\n                model.doAction(del);\r\n                done = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    console.log(\"done removing tabset\");\r\n    return model;\r\n}\r\n\r\n","// Based on https://github.com/streamich/use-media\r\n// simplified for initial implementation\r\n// more research needed to identify best library for media queries, and to expand to be a global App feature in context\r\n// Streamich has some good features, but maybe there is something better\r\nimport React, { DependencyList, EffectCallback } from 'react';\r\n\r\nimport { useState, useEffect, useLayoutEffect } from 'react';\r\n\r\nexport type Effect = (effect: EffectCallback, deps?: DependencyList) => void;\r\n\r\nconst createUseMedia = (effect: Effect) => (\r\n    query: string,\r\n    defaultState = false,\r\n) => {\r\n    const [state, setState] = useState(defaultState);\r\n\r\n    effect(() => {\r\n        let mounted = true;\r\n        const mediaQueryList: MediaQueryList = window.matchMedia(query);\r\n\r\n        const onChange = () => {\r\n            if (!mounted) {\r\n                return;\r\n            }\r\n            setState(Boolean(mediaQueryList.matches));\r\n        };\r\n\r\n        mediaQueryList.addListener(onChange);\r\n        setState(mediaQueryList.matches);\r\n\r\n        return () => {\r\n            mounted = false;\r\n            mediaQueryList.removeListener(onChange);\r\n        };\r\n    }, [query]);\r\n\r\n    return state;\r\n};\r\n\r\nexport const useMedia = createUseMedia(useEffect);\r\nexport const useMediaLayout = createUseMedia(useLayoutEffect);\r\n\r\nexport default useMedia;","import { Model, IJsonModel, Actions, Node as FLNode, DockLocation } from 'flexlayout-react';\r\n\r\nimport { analyseModel, IAnalyzedModel, migrateModel, cloneModel, removeTabset, moveTabset } from './FlexModelUtils';\r\n\r\n\r\n\r\nvar taskTemplateLayout: { name: string, model: IJsonModel } = {\r\n    name: 'task1',\r\n    model: {\r\n        global: {\r\n            \"rootOrientationVertical\": false\r\n        }, // {tabSetEnableTabStrip:false}, // to have just splitters\r\n        layout: {\r\n            \"type\": \"row\",\r\n            \"weight\": 100,\r\n            \"children\": [\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"weight\": 50,\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"panel\": 1\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Comm\",\r\n                            \"component\": \"text\",\r\n                            \"config\": {\r\n                                \"text\": \"Comm\",\r\n                                \"minWidth\": 510,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [1,1,1,1,1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"weight\": 50,\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"panel\": 2\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Letter\",\r\n                            \"component\": \"text\",\r\n                            \"config\": {\r\n                                \"text\": \"Letter\",\r\n                                \"minWidth\": 510,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [1, 1, 2, 2, 2]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"weight\": 50,\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"panel\": 3\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Claims\",\r\n                            \"component\": \"text\",\r\n                            \"config\": {\r\n                                \"text\": \"Claims\",\r\n                                \"minWidth\": 510,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [1,2,3,3,3]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"weight\": 50,\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"panel\": 4\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Fig\",\r\n                            \"component\": \"text\",\r\n                            \"config\": {\r\n                                \"text\": \"Fig\",\r\n                                \"minWidth\": 510,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [1,1,1,1,4]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"weight\": 50,\r\n                    \"selected\": 0,\r\n                    \"config\": {\r\n                        \"panel\": 5\r\n                    },\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"AppAn\",\r\n                            \"component\": \"text\",\r\n                            \"config\": {\r\n                                \"text\": \"AppAn\",\r\n                                \"minWidth\": 510,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [1,2, 3, 4, 5]\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n};\r\n\r\n\r\n\r\n// if maxPanel is undefined, return the canonical model (or in future the user's saved model if there is one, and the canonical model failing that)\r\n// if maxPanel is defined, transform the model \r\nexport const loadTemplateModel = (howToStack: DockLocation, maxPanel?: number,) => {\r\n    let model = Model.fromJson(taskTemplateLayout.model as IJsonModel);\r\n\r\n    if (maxPanel) {\r\n        if (howToStack === DockLocation.BOTTOM) {\r\n            model = moveTabset(model);\r\n        } else {\r\n            model = removeTabset(model, maxPanel + 1);\r\n        }\r\n    }\r\n    const templateModel = analyseModel(model, true);\r\n\r\n    return templateModel;\r\n}","import React, { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport 'flexlayout-react/style/light.css'\r\n\r\nimport { Layout, Model, TabNode, TabSetNode, IJsonModel, Action, Actions, Node as FLNode, DockLocation } from 'flexlayout-react';\r\n\r\nimport { analyseModel, IAnalyzedModel, migrateModel, cloneModel, removeTabset, moveTabset } from './FlexModelUtils';\r\n\r\nimport useMedia from './hooks/useMediaQuery';\r\n\r\nimport { loadTemplateModel } from './LoadTemplate'\r\n\r\n\r\nfunction App() {\r\n  // currentModel is what we're currently rendering.\r\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\r\n  const [stashedModels, _setStashedModels] = useState<IAnalyzedModel[]>(() => { return [loadTemplateModel(DockLocation.CENTER)] });\r\n  const [maxPanels, setMaxPanels] = useState(5);\r\n\r\n  const [canvasToggleAbs, setCanvasToggleAbs] = useState({ height: false, width: false });\r\n  const [stackStrategy, setStackStrategy] = useState('Z');\r\n\r\n\r\n  const layoutRef = useRef(null);\r\n\r\n  const currentModel = stashedModels[stashedModels.length - 1];\r\n\r\n\r\n  const stashPop = () => {\r\n    const newStash = stashedModels.slice(0, -1);\r\n    _setStashedModels(newStash);\r\n  }\r\n\r\n  const stashSet = (model: IAnalyzedModel[]) => {\r\n    _setStashedModels(model);\r\n  }\r\n\r\n\r\n  const downsizeModel = (stackDirection: DockLocation) => {\r\n    let alteredModel = cloneModel(currentModel);\r\n    let previousModelWidth = alteredModel.widthNeeded;\r\n\r\n    const newStash = [...stashedModels];\r\n\r\n    do {\r\n      let m;\r\n      if (stackDirection === DockLocation.BOTTOM) {\r\n        m = moveTabset(alteredModel.model);\r\n      } else {\r\n        m = removeTabset(alteredModel.model);\r\n      }\r\n      alteredModel = analyseModel(m);\r\n\r\n\r\n      // if that helped, push altered model onto the stack\r\n      if (alteredModel.widthNeeded !== previousModelWidth) {\r\n        newStash.push(alteredModel);\r\n      }\r\n      alteredModel = cloneModel(alteredModel);\r\n    } while (alteredModel.widthNeeded !== previousModelWidth && alteredModel.widthNeeded! > window.innerWidth)\r\n    // keep removing tabsets until its narrow enough, or we're not making any further progress\r\n\r\n    // note: cannot use push in a loop because setState is asyncrhonous and only the last call to setState persists\r\n    stashSet(newStash);\r\n  }\r\n\r\n\r\n\r\n  // If the viewport is too narrow for the current model....\r\n  const isTooNarrow = useMedia(`(max-width: ${currentModel.widthNeeded}px)`);\r\n  useEffect(() => {\r\n\r\n    if (isTooNarrow) {\r\n      console.log(\"Too Narrow \" + currentModel.widthNeeded);\r\n\r\n      switch (stackStrategy) {\r\n        case 'X':\r\n          setCanvasToggleAbs({ height: false, width: true });\r\n          break;\r\n        case 'Y':\r\n          console.log(\"Y STACK\")\r\n          downsizeModel(DockLocation.BOTTOM);\r\n          break;\r\n        case 'Z':\r\n          downsizeModel(DockLocation.CENTER);\r\n          setCanvasToggleAbs({ height: false, width: false });\r\n      }\r\n\r\n    } else if (stackStrategy === 'X') {\r\n      // No need for absolute width anymore\r\n      setCanvasToggleAbs({ height: false, width: false });\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isTooNarrow]);\r\n\r\n\r\n  // is the viewport now wide enough to switch back to the previous model?\r\n  const tooWide = stashedModels.length > 1 ? ((stashedModels[stashedModels.length - 2] as IAnalyzedModel).widthNeeded!) : 9999999999;\r\n  const isTooWide = useMedia(`(min-width: ${tooWide}px`);\r\n  useEffect(() => {\r\n\r\n    if (isTooWide) {\r\n      migrateModel(currentModel, stashedModels[stashedModels.length - 2]);\r\n      stashPop();\r\n    }\r\n\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isTooWide]);\r\n\r\n\r\n\r\n  // If too short for current model switch to absolute, \r\n  const isTooShort = useMedia(`(max-height: ${currentModel.heightNeeded}px)`);\r\n  useEffect(() => {\r\n    if (currentModel) {\r\n      if (!isTooShort) {\r\n        setCanvasToggleAbs({ height: false, width: canvasToggleAbs.width });\r\n      } else {\r\n        setCanvasToggleAbs({ height: true, width: canvasToggleAbs.width });\r\n      }\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isTooShort]);\r\n\r\n\r\n  const factory = (node: TabNode) => {\r\n    var component = node.getComponent();\r\n    if (component === \"text\") {\r\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().text }} />;\r\n    }\r\n  }\r\n\r\n  const onAdd = (event: any) => {\r\n    (layoutRef.current! as Layout).addTabWithDragAndDropIndirect(\"Add panel<br>(Drag to location)\", {\r\n      component: \"text\",\r\n      name: \"added\",\r\n      config: { text: \"i was added\", minHeight: 300, minWidth: 400 }\r\n    }, undefined);\r\n  }\r\n\r\n  const interceptAction = (action: Action) => {\r\n\r\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\r\n    // this new tabset will not have a minimum size and so this needs to be set\r\n    // also for deletion of tabs or addition of nodes, the size may be impacted\r\n    setTimeout(() => {\r\n      stashedModels[stashedModels.length - 1] = analyseModel(currentModel.model, true /* update min sizes if needed*/);\r\n    }, 100);\r\n\r\n    return action;\r\n  }\r\n\r\n  const changeStrategy = (event: any) => {\r\n    setCanvasToggleAbs({ height: false, width: false });\r\n    setStackStrategy(event.target.value);\r\n  }\r\n\r\n  const loadPanels = (event: any) => {\r\n    console.log(\"loading ... \");\r\n    setMaxPanels(parseInt(event.target.value));\r\n    stashSet([loadTemplateModel(DockLocation.CENTER, parseInt(event.target.value))]);\r\n  }\r\n\r\n  const modelChanged = (model: Model) => {\r\n    stashedModels[stashedModels.length - 1] = analyseModel(currentModel.model, false /* avoid infintie loop*/);\r\n  }\r\n\r\n  const absStyle = {\r\n    height: canvasToggleAbs.height ? currentModel.heightNeeded + 'px' : '100%',\r\n    width: canvasToggleAbs.width ? currentModel.widthNeeded + 'px' : '100%'\r\n  };\r\n\r\n\r\n  return (\r\n    <div className=\"outer\" style={absStyle}>\r\n      <button onClick={onAdd}>Add Panel</button>\r\n      <span> Stacking strategy:</span>\r\n      <select value={stackStrategy} onChange={changeStrategy}>\r\n        <option value=\"X\">X axis</option>\r\n        <option value=\"Y\">Y axis</option>\r\n        <option value=\"Z\">Z axis</option>\r\n      </select>\r\n      <span> Number of Panels:</span>\r\n      <select value={maxPanels} onChange={loadPanels}>\r\n        <option value=\"1\">1</option>\r\n        <option value=\"2\">2</option>\r\n        <option value=\"3\">3</option>\r\n        <option value=\"4\">4</option>\r\n        <option value=\"5\">5</option>\r\n      </select>\r\n      <div className=\"inner\" >\r\n        {currentModel && (\r\n          <Layout ref={layoutRef}\r\n            onAction={interceptAction}\r\n            onModelChange={modelChanged}\r\n            model={currentModel.model}\r\n            factory={factory} />)}\r\n      </div>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}