{"version":3,"sources":["FlexModelUtils.ts","hooks/useMediaQuery.ts","App.tsx","index.tsx"],"names":["analyseRow","row","updateIfNeeded","widthNeeded","heightNeeded","getChildren","forEach","node","getType","TabSetNode","TYPE","ts","tabset","TabNode","Error","t","Math","max","getConfig","minHeight","minWidth","getMinWidth","getMinHeight","setSize","Actions","updateNodeAttributes","getId","getModel","doAction","getTabSetMinSize","getOrientation","Orientation","HORZ","RowNode","size","analyseModel","modelToAnalyse","prioTabset","undefined","activeTabset","rootRow","getRoot","console","log","visitNodes","toLowerCase","isActive","result","model","toJson","createUseMedia","effect","query","defaultState","useState","state","setState","mounted","mediaQueryList","window","matchMedia","onChange","Boolean","matches","addListener","removeListener","useMedia","useEffect","useLayoutEffect","templateModel","Model","fromJson","global","layout","App","stashedModels","currentModel","_setCurrentModel","height","width","canvasToggleAbs","setCanvasToggleAbs","stackStrategy","setStackStrategy","layoutRef","useRef","setCurrentModel","length","isTooNarrow","alteredModel","modelToAdapt","modelToClone","saveCurrentJson","clone","cloneModel","targetRow","tabSetsToMove","success","push","mv","moveNode","DockLocation","BOTTOM","getParent","stackYAxis","targetTabset","tabsToMove","CENTER","stackZAxis","tooWide","isTooWide","sourceModel","targetModel","lastTabSet","actions","getNodeById","deleteTab","parent","addNode","RIGHT","action","migrateModel","pop","isTooShort","absStyle","className","style","value","event","target","onClick","current","addTabWithDragAndDropIndirect","component","name","config","text","ref","onAction","setTimeout","onModelChange","factory","getComponent","dangerouslySetInnerHTML","__html","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.30eab79e.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\n\r\n\r\n\r\nexport interface IAnalyzedModel {\r\n    model: Model,\r\n    activeTabset: FLNode | undefined,\r\n    prioTabset: FLNode | undefined,\r\n    widthNeeded?: number,\r\n    heightNeeded?: number,\r\n    rootRow?: FLNode | undefined\r\n}\r\n\r\ninterface IDimensions {\r\n    widthNeeded: number,\r\n    heightNeeded: number,\r\n}\r\n\r\n\r\nconst getTabSetMinSize = (tabset: TabSetNode, updateIfNeeded: boolean): IDimensions => {\r\n    let heightNeeded = 0;\r\n    let widthNeeded = 0;\r\n\r\n    // iterate through the tabs to get min sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const t = node as TabNode;\r\n        heightNeeded = Math.max(heightNeeded, t.getConfig().minHeight);\r\n        widthNeeded = Math.max(widthNeeded, t.getConfig().minWidth);\r\n\r\n    })\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if ((updateIfNeeded && (heightNeeded > 0 || widthNeeded > 0)) &&\r\n        (tabset.getMinWidth() != widthNeeded || tabset.getMinHeight() != heightNeeded)) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n        const setSize = Actions.updateNodeAttributes(tabset.getId(), { minWidth: widthNeeded, minHeight: heightNeeded });\r\n        tabset.getModel().doAction(setSize);\r\n    }\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded\r\n    }\r\n\r\n}\r\n\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean): IDimensions => {\r\n    let widthNeeded = 0;\r\n    let heightNeeded = 0;\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = getTabSetMinSize(node as TabSetNode, updateIfNeeded);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                widthNeeded += ts.widthNeeded;\r\n                heightNeeded = Math.max(heightNeeded, ts.heightNeeded);\r\n            } else {\r\n                widthNeeded = Math.max(widthNeeded, ts.widthNeeded);\r\n                heightNeeded += ts.heightNeeded;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const size = analyseRow(node as RowNode, updateIfNeeded);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                if (size.widthNeeded) widthNeeded += size.widthNeeded;\r\n                if (size.heightNeeded) heightNeeded = Math.max(heightNeeded, size.heightNeeded);\r\n            } else {\r\n                if (size.widthNeeded) widthNeeded = Math.max(widthNeeded, size.widthNeeded);\r\n                if (size.heightNeeded) heightNeeded += size.heightNeeded;\r\n            }\r\n        }\r\n    })\r\n\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded\r\n    }\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = false): IAnalyzedModel => {\r\n\r\n    let prioTabset: TabSetNode | undefined = undefined;\r\n    let activeTabset: TabSetNode | undefined = undefined;\r\n    let rootRow = modelToAnalyse.getRoot();\r\n\r\n\r\n    console.log(\"Too doing analysis (\" + updateIfNeeded);\r\n    // find the tabset that is currently active, and also the first tabset (as fallback)\r\n    modelToAnalyse.visitNodes(node => {\r\n\r\n        if (!prioTabset && node.getType().toLowerCase() === 'tabset') prioTabset = node as TabSetNode;\r\n\r\n        if (!activeTabset && node.getType().toLowerCase() === 'tabset' && (node as TabSetNode).isActive()) {\r\n            activeTabset = node as TabSetNode;\r\n        }\r\n\r\n    });\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(rootRow, updateIfNeeded);\r\n\r\n    console.log(\"done\");\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        activeTabset: activeTabset,\r\n        prioTabset: prioTabset,\r\n        rootRow,\r\n        widthNeeded: size.widthNeeded,\r\n        heightNeeded: size.heightNeeded\r\n    }\r\n\r\n    console.log(modelToAnalyse.toJson());\r\n\r\n    console.log(`SIZE : ${size.heightNeeded} x ${size.widthNeeded}`)\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\nexport const stackZAxis = (modelToAdapt: IAnalyzedModel): IAnalyzedModel | undefined => {\r\n    let targetTabset: FLNode = modelToAdapt.activeTabset ? modelToAdapt.activeTabset : modelToAdapt.prioTabset!;\r\n    let tabsToMove: FLNode[] = [];\r\n\r\n    let success = false;\r\n\r\n\r\n    modelToAdapt.model.visitNodes((node) => {\r\n        console.log(node.getType() + \" is \" + node.getId());\r\n        if (node.getParent()) {\r\n            console.log(\" and parent is: \" + node!.getParent()!.getId());\r\n\r\n        } else {\r\n            console.log(\"none\")\r\n        }\r\n        if (node.getType().toLowerCase() === 'tab' && node.getParent()?.getId() !== targetTabset!.getId()) {\r\n            tabsToMove.push(node);\r\n        }\r\n    });\r\n\r\n    tabsToMove.forEach(node => {\r\n        let mv = Actions.moveNode(node.getId(), targetTabset?.getId(), DockLocation.CENTER, -1, false);\r\n        modelToAdapt.model.doAction(mv);\r\n        success = true;\r\n    })\r\n\r\n    if (success) {\r\n        return analyseModel(modelToAdapt.model);;\r\n    } else {\r\n        return undefined;\r\n    }\r\n\r\n}\r\n\r\nexport const stackYAxis = (modelToAdapt: IAnalyzedModel): IAnalyzedModel | undefined => {\r\n    let activeTabset: FLNode = modelToAdapt.activeTabset ? modelToAdapt.activeTabset : modelToAdapt.prioTabset!;\r\n    let targetRow = modelToAdapt.rootRow;\r\n    let tabSetsToMove: FLNode[] = [];\r\n\r\n    let success = false;\r\n\r\n    if (targetRow) {\r\n\r\n        modelToAdapt.model.visitNodes((node) => {\r\n            console.log(node.getType() + \" is \" + node.getId());\r\n            if (node.getType().toLowerCase() === 'tabset' && node.getId() !== activeTabset.getId()) {\r\n                tabSetsToMove.push(node);\r\n            }\r\n        });\r\n\r\n\r\n        tabSetsToMove.forEach(node => {\r\n            let mv = Actions.moveNode(node.getId(), targetRow!.getId(), DockLocation.BOTTOM, -1);\r\n\r\n            console.log(mv);\r\n\r\n            console.log(\"before parent IS \" + node.getParent()!.getId())\r\n            console.log(\"node is \"); console.log(node.toJson());\r\n            modelToAdapt.model.doAction(mv);\r\n            success = true;\r\n\r\n\r\n            // targetRow = node.getParent();\r\n            console.log(\"after parent IS \" + node.getParent()!.getId())\r\n\r\n        })\r\n\r\n    }\r\n\r\n    if (success) {\r\n        return analyseModel(modelToAdapt.model);;\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport const migrateModel = (sourceModel: IAnalyzedModel, targetModel: IAnalyzedModel) => {\r\n    let actions: Action[] = [];\r\n    let lastTabSet: TabSetNode;\r\n    console.log(\"migrating model\");\r\n\r\n    // Which nodes need to be deleted from target?\r\n    targetModel.model.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            if (!sourceModel.model.getNodeById(node.getId())) {\r\n                actions.push(Actions.deleteTab(node.getId()));\r\n            }\r\n        } else if (node.getType() === TabSetNode.TYPE) {\r\n            lastTabSet = node as TabSetNode;\r\n        }\r\n    })\r\n\r\n    // which nodes need to added to the target?\r\n    sourceModel.model.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            if (!targetModel.model.getNodeById(node.getId())) {\r\n                // add to the same parent if possible\r\n                const parent = node.getParent();\r\n                if (parent!.getType() === TabSetNode.TYPE && targetModel.model.getNodeById(parent!.getId())) {\r\n                    actions.push(Actions.addNode(node.toJson(), parent!.getId(), DockLocation.CENTER, -1, false));\r\n                } else {\r\n                    // Otherwise add to the last tabset in the model\r\n                    if (lastTabSet) {\r\n                        actions.push(Actions.addNode(node.toJson(), lastTabSet.getId(), DockLocation.CENTER, -1, false));\r\n                    } else {\r\n                        actions.push(Actions.addNode(node.toJson(), targetModel.model.getRoot().getId(), DockLocation.RIGHT, -1, false));\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    });\r\n\r\n    actions.forEach(action => {\r\n        targetModel.model.doAction(action);\r\n    });\r\n}\r\n\r\n\r\n","// Based on https://github.com/streamich/use-media\r\n// simplified for initial implementation\r\n// more research needed to identify best library for media queries, and to expand to be a global App feature in context\r\n// Streamich has some good features, but maybe there is something better\r\nimport React, { DependencyList, EffectCallback } from 'react';\r\n\r\nimport { useState, useEffect, useLayoutEffect } from 'react';\r\n\r\nexport type Effect = (effect: EffectCallback, deps?: DependencyList) => void;\r\n\r\nconst createUseMedia = (effect: Effect) => (\r\n    query: string,\r\n    defaultState = false,\r\n) => {\r\n    const [state, setState] = useState(defaultState);\r\n\r\n    effect(() => {\r\n        let mounted = true;\r\n        const mediaQueryList: MediaQueryList = window.matchMedia(query);\r\n\r\n        const onChange = () => {\r\n            if (!mounted) {\r\n                return;\r\n            }\r\n            setState(Boolean(mediaQueryList.matches));\r\n        };\r\n\r\n        mediaQueryList.addListener(onChange);\r\n        setState(mediaQueryList.matches);\r\n\r\n        return () => {\r\n            mounted = false;\r\n            mediaQueryList.removeListener(onChange);\r\n        };\r\n    }, [query]);\r\n\r\n    return state;\r\n};\r\n\r\nexport const useMedia = createUseMedia(useEffect);\r\nexport const useMediaLayout = createUseMedia(useLayoutEffect);\r\n\r\nexport default useMedia;","import React, { useEffect, useRef, useState } from 'react';\nimport './App.css';\nimport 'flexlayout-react/style/light.css'\n\nimport { Layout, Model, TabNode, TabSetNode, IJsonModel, Action, Actions, Node as FLNode } from 'flexlayout-react';\n\nimport { analyseModel, stackZAxis, IAnalyzedModel, stackYAxis, migrateModel, cloneModel } from './FlexModelUtils';\n\nimport useMedia from './hooks/useMediaQuery';\n\nvar json: IJsonModel = {\n  global: {\n    \"rootOrientationVertical\": false\n  }, // {tabSetEnableTabStrip:false}, // to have just splitters\n  layout: {\n    \"type\": \"row\",\n    \"weight\": 100,\n    \"children\": [\n      {\n        \"type\": \"tabset\",\n        \"weight\": 50,\n        \"selected\": 0,\n        \"children\": [\n          {\n            \"type\": \"tab\",\n            \"name\": \"Things to try\",\n            \"component\": \"text\",\n            \"config\": {\n              \"text\": \"<ul><li>drag tabs</li><li>drag splitters</li><li>double click on tab to rename</li><li>double click on tabstrip to maximize</li><li>use the Add button to add another tab</li></ul>\",\n              \"minWidth\": 510,\n              \"minHeight\": 350,\n            }\n          }\n        ]\n      },\n\n      {\n        \"type\": \"tabset\",\n        \"weight\": 50,\n        \"selected\": 0,\n        \"children\": [\n          {\n            \"type\": \"tab\",\n            \"name\": \"two\",\n            \"component\": \"text\",\n            \"config\": {\n              \"text\": \"\",\n              \"minWidth\": 510,\n              \"minHeight\": 350,\n            }\n          }\n        ]\n      },\n      {\n        \"type\": \"tabset\",\n        \"weight\": 50,\n        \"selected\": 0,\n        \"children\": [\n          {\n            \"type\": \"tab\",\n            \"name\": \"three\",\n            \"component\": \"text\",\n            \"config\": {\n              \"text\": \"\",\n              \"minWidth\": 510,\n              \"minHeight\": 350\n            }\n          }\n        ]\n      }\n\n\n    ]\n  }\n};\n\nconst templateModel = analyseModel(Model.fromJson(json), true);\n\n\nfunction App() {\n  // currentModel is what we're currently rendering.\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\n  const [stashedModels] = useState<IAnalyzedModel[]>([templateModel]);\n  const [currentModel, _setCurrentModel] = useState(() => { return stashedModels[0] });\n\n  const [canvasToggleAbs, setCanvasToggleAbs] = useState({ height: false, width: false });\n  const [stackStrategy, setStackStrategy] = useState('Z');\n\n  const containerRef = useRef(null);\n  const layoutRef = useRef(null);\n\n\n  const setCurrentModel = () => {\n    // make sure that the current model is always pointing to the last in the stashed list\n    _setCurrentModel(stashedModels[stashedModels.length - 1]);\n  }\n\n\n\n  // If the viewport is too narrow for the current model....\n  const isTooNarrow = useMedia(`(max-width: ${currentModel.widthNeeded}px)`);\n  useEffect(() => {\n    console.log(`Too narrow: ${isTooNarrow} ${currentModel.widthNeeded}`)\n\n    if (isTooNarrow) {\n\n      let modelToAdapt = cloneModel(currentModel);\n\n      // alter current model\n      let alteredModel: IAnalyzedModel | undefined;\n\n      switch (stackStrategy) {\n        case 'X':\n          setCanvasToggleAbs({ height: false, width: true });\n          break;\n        case 'Y':\n          alteredModel = stackYAxis(modelToAdapt);\n          break;\n        case 'Z':\n          alteredModel = stackZAxis(modelToAdapt);\n          setCanvasToggleAbs({ height: false, width: false });\n      }\n\n      // If the adaption was successful, make this altered model the new current\n      if (alteredModel) {\n        stashedModels.push(alteredModel);\n        console.log(\"Too Switching to NEW model: \" + stashedModels.length);\n        setCurrentModel();\n\n      }\n\n    } else if (stackStrategy === 'X') {\n      // No need for absolute width anymore\n      setCanvasToggleAbs({ height: false, width: false });\n    }\n  }, [isTooNarrow]);\n\n\n  // is the viewport now wide enough to switch back to the previous model?\n  const tooWide = stashedModels.length > 1 ? ((stashedModels[stashedModels.length - 2] as IAnalyzedModel).widthNeeded!) : 9999999999;\n  const isTooWide = useMedia(`(min-width: ${tooWide}px`);\n  useEffect(() => {\n    console.log(`Too wide: ${isTooWide} ${tooWide} (looking at ${stashedModels.length - 2})`)\n\n\n    if (isTooWide) {\n      console.log(\"Too Switching BACK to  model: \" + (stashedModels.length - 2));\n\n      migrateModel(currentModel, stashedModels[stashedModels.length - 2]);\n      stashedModels.pop();\n      setCurrentModel();\n    }\n\n  }, [isTooWide]);\n\n\n\n  // If too short for current model switch to absolute, \n  const isTooShort = useMedia(`(max-height: ${currentModel.heightNeeded}px)`);\n  useEffect(() => {\n    if (currentModel) {\n      if (!isTooShort) {\n        setCanvasToggleAbs({ height: false, width: canvasToggleAbs.width });\n        console.log(\"REL CANVAS :\" + currentModel.heightNeeded);\n      } else {\n        setCanvasToggleAbs({ height: true, width: canvasToggleAbs.width });\n\n        console.log(\"ABS CANVAS :\" + currentModel.heightNeeded);\n      }\n    }\n  }, [isTooShort]);\n\n\n  const factory = (node: TabNode) => {\n    var component = node.getComponent();\n    if (component === \"text\") {\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().text }} />;\n    }\n  }\n\n  const onAdd = (event: any) => {\n    (layoutRef.current! as Layout).addTabWithDragAndDropIndirect(\"Add panel<br>(Drag to location)\", {\n      component: \"text\",\n      name: \"added\",\n      config: { text: \"i was added\", minHeight: 300, minWidth: 400 }\n    }, undefined);\n  }\n\n  const interceptAction = (action: Action) => {\n    console.log(action);\n\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\n    // this new tabset will not have a minimum size and so this needs to be set\n    // also for deletion of tabs or addition of nodes, the size may be impacted\n    setTimeout(() => {\n      console.log(\"Too timer...\");\n      stashedModels[stashedModels.length - 1] = analyseModel(currentModel.model, true /* update min sizes if needed*/);\n      setCurrentModel();\n    }, 100);\n\n    return action;\n  }\n\n  const changeStrategy = (event: any) => {\n    setCanvasToggleAbs({ height: false, width: false });\n    setStackStrategy(event.target.value);\n  }\n\n  const modelChanged = (model: Model) => {\n    console.log(\"Too model changed\");\n    console.log(model);\n\n    stashedModels[stashedModels.length - 1] = analyseModel(currentModel.model, false /* avoid infintie loop*/);\n    setCurrentModel();\n\n  }\n\n  const absStyle = {\n    height: canvasToggleAbs.height ? currentModel.heightNeeded + 'px' : '100%',\n    width: canvasToggleAbs.width ? currentModel.widthNeeded + 'px' : '100%'\n  };\n\n  return (\n\n\n    <div className=\"outer\" style={absStyle}>\n      <span> Stacking strategy:</span>\n      <select value={stackStrategy} onChange={changeStrategy}>\n        <option value=\"X\">X axis</option>\n        <option value=\"Y\">Y axis</option>\n        <option value=\"Z\">Z axis</option>\n      </select>\n      <button onClick={onAdd}>Add</button>\n      <div className=\"inner\" >\n        {currentModel && (\n          <Layout ref={layoutRef}\n            onAction={interceptAction}\n            onModelChange={modelChanged}\n            model={currentModel.model}\n            factory={factory} />)}\n      </div>\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}